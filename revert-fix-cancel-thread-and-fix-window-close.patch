From 98cb13e17f73f1c7346891506a366eca3d2b1f92 Mon Sep 17 00:00:00 2001
From: Aleksei Bavshin <alebastr89@gmail.com>
Date: Wed, 2 Sep 2020 09:54:26 -0700
Subject: [PATCH] Revert "fix: cancel thread and fix window close"

This reverts commit 6e7f22ac3ada6e27facee84fcbe2b3973eadbe1d.
---
 include/AModule.hpp             |  6 ++---
 include/bar.hpp                 |  2 +-
 include/modules/network.hpp     |  2 ++
 include/util/rfkill.hpp         |  4 +--
 include/util/sleeper_thread.hpp |  5 ----
 src/AModule.cpp                 |  5 ++--
 src/bar.cpp                     |  2 +-
 src/client.cpp                  |  3 +--
 src/modules/mpd.cpp             | 30 +++++++++++----------
 src/modules/network.cpp         | 47 +++++++++++++++++++++++++++++++++
 src/util/rfkill.cpp             | 33 +++++++++++++----------
 11 files changed, 93 insertions(+), 46 deletions(-)

diff --git a/include/AModule.hpp b/include/AModule.hpp
index c9f1ae2..f7cc484 100644
--- a/include/AModule.hpp
+++ b/include/AModule.hpp
@@ -4,15 +4,14 @@
 #include <glibmm/markup.h>
 #include <gtkmm/eventbox.h>
 #include <json/json.h>
-
 #include "IModule.hpp"
 
 namespace waybar {
 
 class AModule : public IModule {
  public:
-  AModule(const Json::Value &, const std::string &, const std::string &, bool enable_click = false,
-          bool enable_scroll = false);
+  AModule(const Json::Value &, const std::string &, const std::string &,
+          bool enable_click = false, bool enable_scroll = false);
   virtual ~AModule();
   virtual auto update() -> void;
   virtual      operator Gtk::Widget &();
@@ -25,7 +24,6 @@ class AModule : public IModule {
   SCROLL_DIR getScrollDir(GdkEventScroll *e);
   bool       tooltipEnabled();
 
-  const std::string  name_;
   const Json::Value &config_;
   Gtk::EventBox      event_box_;
 
diff --git a/include/bar.hpp b/include/bar.hpp
index 63f0e22..fb0cd59 100644
--- a/include/bar.hpp
+++ b/include/bar.hpp
@@ -34,10 +34,10 @@ class Bar {
 
   struct waybar_output *output;
   Json::Value           config;
+  Gtk::Window           window;
   struct wl_surface *   surface;
   bool                  visible = true;
   bool                  vertical = false;
-  Gtk::Window           window;
 
  private:
   static constexpr const char *MIN_HEIGHT_MSG =
diff --git a/include/modules/network.hpp b/include/modules/network.hpp
index a0156fb..edb5aa6 100644
--- a/include/modules/network.hpp
+++ b/include/modules/network.hpp
@@ -52,6 +52,8 @@ class Network : public ALabel {
   struct sockaddr_nl nladdr_ = {0};
   struct nl_sock*    sock_ = nullptr;
   struct nl_sock*    ev_sock_ = nullptr;
+  int                efd_;
+  int                ev_fd_;
   int                nl80211_id_;
   std::mutex         mutex_;
 
diff --git a/include/util/rfkill.hpp b/include/util/rfkill.hpp
index ac3d406..5dbf3ce 100644
--- a/include/util/rfkill.hpp
+++ b/include/util/rfkill.hpp
@@ -5,7 +5,7 @@
 namespace waybar::util {
 
 class Rfkill {
- public:
+ public:;
   Rfkill(enum rfkill_type rfkill_type);
   ~Rfkill() = default;
   void waitForEvent();
@@ -13,7 +13,7 @@ class Rfkill {
 
  private:
   enum rfkill_type rfkill_type_;
-  int              state_ = 0;
+  int state_ = 0;
 };
 
 }  // namespace waybar::util
diff --git a/include/util/sleeper_thread.hpp b/include/util/sleeper_thread.hpp
index 9adbe8f..642d47d 100644
--- a/include/util/sleeper_thread.hpp
+++ b/include/util/sleeper_thread.hpp
@@ -59,11 +59,6 @@ class SleeperThread {
       do_run_ = false;
     }
     condvar_.notify_all();
-    auto handle = thread_.native_handle();
-    if (handle != 0) {
-      // TODO: find a proper way to terminate thread...
-      pthread_cancel(handle);
-    }
   }
 
   ~SleeperThread() {
diff --git a/src/AModule.cpp b/src/AModule.cpp
index 10bd077..3066bfc 100644
--- a/src/AModule.cpp
+++ b/src/AModule.cpp
@@ -6,7 +6,7 @@ namespace waybar {
 
 AModule::AModule(const Json::Value& config, const std::string& name, const std::string& id,
                  bool enable_click, bool enable_scroll)
-    : name_(std::move(name)), config_(std::move(config)) {
+    : config_(std::move(config)) {
   // configure events' user commands
   if (config_["on-click"].isString() || config_["on-click-middle"].isString() ||
       config_["on-click-backward"].isString() || config_["on-click-forward"].isString() ||
@@ -23,12 +23,11 @@ AModule::AModule(const Json::Value& config, const std::string& name, const std::
 AModule::~AModule() {
   for (const auto& pid : pid_) {
     if (pid != -1) {
-      killpg(pid, SIGTERM);
+      kill(-pid, 9);
     }
   }
 }
 
-
 auto AModule::update() -> void {
   // Run user-provided update handler if configured
   if (config_["on-update"].isString()) {
diff --git a/src/bar.cpp b/src/bar.cpp
index 3bbc2a3..72dc14b 100644
--- a/src/bar.cpp
+++ b/src/bar.cpp
@@ -10,8 +10,8 @@
 waybar::Bar::Bar(struct waybar_output* w_output, const Json::Value& w_config)
     : output(w_output),
       config(w_config),
-      surface(nullptr),
       window{Gtk::WindowType::WINDOW_TOPLEVEL},
+      surface(nullptr),
       layer_surface_(nullptr),
       anchor_(ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP),
       left_(Gtk::ORIENTATION_HORIZONTAL, 0),
diff --git a/src/client.cpp b/src/client.cpp
index 316e7ec..dee28a4 100644
--- a/src/client.cpp
+++ b/src/client.cpp
@@ -145,8 +145,7 @@ void waybar::Client::handleMonitorRemoved(Glib::RefPtr<Gdk::Monitor> monitor) {
   for (auto it = bars.begin(); it != bars.end();) {
     if ((*it)->output->monitor == monitor) {
       auto output_name = (*it)->output->name;
-      (*it)->window.hide();
-      gtk_app->remove_window((*it)->window);
+      (*it)->window.close();
       it = bars.erase(it);
       spdlog::info("Bar removed from output: {}", output_name);
     } else {
diff --git a/src/modules/mpd.cpp b/src/modules/mpd.cpp
index 957b3c7..d2877f3 100644
--- a/src/modules/mpd.cpp
+++ b/src/modules/mpd.cpp
@@ -63,20 +63,22 @@ auto waybar::modules::MPD::update() -> void {
 
 std::thread waybar::modules::MPD::event_listener() {
   return std::thread([this] {
-    try {
-      if (connection_ == nullptr) {
-        // Retry periodically if no connection
-        dp.emit();
-        std::this_thread::sleep_for(interval_);
-      } else {
-        waitForEvent();
-        dp.emit();
-      }
-    } catch (const std::exception& e) {
-      if (strcmp(e.what(), "Connection to MPD closed") == 0) {
-        spdlog::debug("{}: {}", module_name_, e.what());
-      } else {
-        spdlog::warn("{}: {}", module_name_, e.what());
+    while (true) {
+      try {
+        if (connection_ == nullptr) {
+          // Retry periodically if no connection
+          dp.emit();
+          std::this_thread::sleep_for(interval_);
+        } else {
+          waitForEvent();
+          dp.emit();
+        }
+      } catch (const std::exception& e) {
+        if (strcmp(e.what(), "Connection to MPD closed") == 0) {
+          spdlog::debug("{}: {}", module_name_, e.what());
+        } else {
+          spdlog::warn("{}: {}", module_name_, e.what());
+        }
       }
     }
   });
diff --git a/src/modules/network.cpp b/src/modules/network.cpp
index 2c0562f..035454e 100644
--- a/src/modules/network.cpp
+++ b/src/modules/network.cpp
@@ -81,6 +81,8 @@ waybar::modules::Network::Network(const std::string &id, const Json::Value &conf
     : ALabel(config, "network", id, "{ifname}", 60),
       ifid_(-1),
       family_(config["family"] == "ipv6" ? AF_INET6 : AF_INET),
+      efd_(-1),
+      ev_fd_(-1),
       cidr_(-1),
       signal_strength_dbm_(0),
       signal_strength_(0),
@@ -115,6 +117,14 @@ waybar::modules::Network::Network(const std::string &id, const Json::Value &conf
 }
 
 waybar::modules::Network::~Network() {
+  if (ev_fd_ > -1) {
+    eventfd_write(ev_fd_, 1);
+    std::this_thread::sleep_for(std::chrono::milliseconds(150));
+    close(ev_fd_);
+  }
+  if (efd_ > -1) {
+    close(efd_);
+  }
   if (ev_sock_ != nullptr) {
     nl_socket_drop_membership(ev_sock_, RTNLGRP_LINK);
     if (family_ == AF_INET) {
@@ -146,6 +156,30 @@ void waybar::modules::Network::createEventSocket() {
   } else {
     nl_socket_add_membership(ev_sock_, RTNLGRP_IPV6_IFADDR);
   }
+  efd_ = epoll_create1(EPOLL_CLOEXEC);
+  if (efd_ < 0) {
+    throw std::runtime_error("Can't create epoll");
+  }
+  {
+    ev_fd_ = eventfd(0, EFD_NONBLOCK);
+    struct epoll_event event;
+    memset(&event, 0, sizeof(event));
+    event.events = EPOLLIN | EPOLLET;
+    event.data.fd = ev_fd_;
+    if (epoll_ctl(efd_, EPOLL_CTL_ADD, ev_fd_, &event) == -1) {
+      throw std::runtime_error("Can't add epoll event");
+    }
+  }
+  {
+    auto               fd = nl_socket_get_fd(ev_sock_);
+    struct epoll_event event;
+    memset(&event, 0, sizeof(event));
+    event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;
+    event.data.fd = fd;
+    if (epoll_ctl(efd_, EPOLL_CTL_ADD, fd, &event) == -1) {
+      throw std::runtime_error("Can't add epoll event");
+    }
+  }
 }
 
 void waybar::modules::Network::createInfoSocket() {
@@ -184,6 +218,19 @@ void waybar::modules::Network::worker() {
       }
     }
   };
+  thread_ = [this] {
+    std::array<struct epoll_event, EPOLL_MAX> events{};
+
+    int ec = epoll_wait(efd_, events.data(), EPOLL_MAX, -1);
+    if (ec > 0) {
+      for (auto i = 0; i < ec; i++) {
+        if (events[i].data.fd != nl_socket_get_fd(ev_sock_) || nl_recvmsgs_default(ev_sock_) < 0) {
+          thread_.stop();
+          break;
+        }
+      }
+    }
+  };
 }
 
 const std::string waybar::modules::Network::getNetworkState() const {
diff --git a/src/util/rfkill.cpp b/src/util/rfkill.cpp
index f987f4c..df77598 100644
--- a/src/util/rfkill.cpp
+++ b/src/util/rfkill.cpp
@@ -3,11 +3,11 @@
  * Copyright 2009 Johannes Berg <johannes@sipsolutions.net>
  * Copyright 2009 Marcel Holtmann <marcel@holtmann.org>
  * Copyright 2009 Tim Gardner <tim.gardner@canonical.com>
- *
+ * 
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
- *
+ * 
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -17,24 +17,24 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
 
 #include "util/rfkill.hpp"
-
-#include <fcntl.h>
 #include <linux/rfkill.h>
+#include <unistd.h>
 #include <stdlib.h>
+#include <cstring>
+#include <fcntl.h>
 #include <sys/poll.h>
-#include <unistd.h>
-
 #include <cerrno>
-#include <cstring>
 #include <stdexcept>
 
-waybar::util::Rfkill::Rfkill(const enum rfkill_type rfkill_type) : rfkill_type_(rfkill_type) {}
+waybar::util::Rfkill::Rfkill(const enum rfkill_type rfkill_type)
+  : rfkill_type_(rfkill_type) {
+}
 
 void waybar::util::Rfkill::waitForEvent() {
   struct rfkill_event event;
-  struct pollfd       p;
-  ssize_t             len;
-  int                 fd, n;
+  struct pollfd p;
+  ssize_t len;
+  int fd, n;
 
   fd = open("/dev/rfkill", O_RDONLY);
   if (fd < 0) {
@@ -53,7 +53,8 @@ void waybar::util::Rfkill::waitForEvent() {
       break;
     }
 
-    if (n == 0) continue;
+    if (n == 0)
+      continue;
 
     len = read(fd, &event, sizeof(event));
     if (len < 0) {
@@ -66,13 +67,17 @@ void waybar::util::Rfkill::waitForEvent() {
       continue;
     }
 
-    if (event.type == rfkill_type_ && event.op == RFKILL_OP_CHANGE) {
+    if(event.type == rfkill_type_ && event.op == RFKILL_OP_CHANGE) {
       state_ = event.soft || event.hard;
       break;
     }
   }
 
   close(fd);
+  return;
 }
 
-bool waybar::util::Rfkill::getState() const { return state_; }
+
+bool waybar::util::Rfkill::getState() const {
+  return state_;
+}
-- 
2.26.2

